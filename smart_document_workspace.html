<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Document Workspace - Commercial Edition</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0/dist/transformers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <style>
        /* Custom Styles */
        .sidebar {
            width: 300px;
            min-width: 300px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8fafc;
        }
        
        .message-bubble {
            max-width: 80%;
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-in;
        }
        
        .message-user {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        
        .message-assistant {
            background: white;
            color: #374151;
            margin-right: auto;
            border: 1px solid #e5e7eb;
            border-bottom-left-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .message-error {
            background: #fee2e2;
            color: #dc2626;
            margin-right: auto;
            border: 1px solid #fecaca;
            border-bottom-left-radius: 4px;
        }
        
        .chat-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e5e7eb;
        }
        
        .chat-input {
            width: 100%;
            min-height: 44px;
            max-height: 120px;
            padding: 12px 50px 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 22px;
            resize: none;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .chat-input:focus {
            border-color: #667eea;
        }
        
        .send-button {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .send-button:hover {
            transform: translateY(-50%) scale(1.05);
        }
        
        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: translateY(-50%);
        }
        
        .room-item {
            padding: 12px 16px;
            margin: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .room-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }
        
        .room-item.active {
            background: rgba(255, 255, 255, 0.25);
            border-left: 4px solid #fbbf24;
        }
        
        .room-name {
            font-weight: 600;
            color: white;
            margin-bottom: 4px;
        }
        
        .room-details {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }
        
        .form-input, .form-select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-size: 14px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }
        
        .btn-secondary:hover {
            background: #e5e7eb;
        }
        
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            margin-bottom: 16px;
            background: white;
            border-radius: 18px;
            border-bottom-left-radius: 4px;
            max-width: 80px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .typing-dots {
            display: flex;
            gap: 4px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            background: #9ca3af;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            color: #374151;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 999;
            font-size: 12px;
            text-align: center;
            max-width: 250px;
            animation: notificationSlide 0.3s ease-out;
        }
        
        .notification.success {
            background: #10b981;
            color: white;
        }
        
        .notification.error {
            background: #ef4444;
            color: white;
        }
        
        @keyframes notificationSlide {
            from { transform: translateX(-50%) translateY(-100%); }
            to { transform: translateX(-50%) translateY(0); }
        }
        
        /* File upload styles */
        .file-drop-zone {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .file-drop-zone:hover, .file-drop-zone.dragover {
            border-color: #667eea;
            background: #f8fafc;
        }
        
        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 16px 0;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            justify-content: between;
            padding: 8px 12px;
            background: #f3f4f6;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }
        
        /* Settings styles */
        .settings-section {
            margin-bottom: 24px;
            padding-bottom: 24px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .settings-title {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .model-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f9fafb;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        
        .slider-container {
            margin: 16px 0;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-top: 16px;
        }
        
        .performance-item {
            text-align: center;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .performance-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }
        
        .performance-label {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                min-width: 100%;
                position: fixed;
                top: 0;
                left: -100%;
                height: 100vh;
                z-index: 999;
                transition: left 0.3s ease;
            }
            
            .sidebar.show {
                left: 0;
            }
            
            .chat-container {
                width: 100%;
            }
            
            .message-bubble {
                max-width: 90%;
            }
            
            .modal-content {
                width: 95%;
                margin: 20px;
            }
        }
        
        /* Welcome screen */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .welcome-icon {
            font-size: 64px;
            margin-bottom: 24px;
            color: #d1d5db;
        }
        
        .welcome-title {
            font-size: 24px;
            font-weight: 700;
            color: #374151;
            margin-bottom: 16px;
        }
        
        .welcome-description {
            font-size: 16px;
            line-height: 1.6;
            max-width: 500px;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <!--
    ================================================================================
    SMART DOCUMENT WORKSPACE
    ================================================================================
    Author: Tomio Kobayashi
    Version: 2.0.0
    Created: 2025/07/13

    Description:
    A revolutionary client-side RAG (Retrieval-Augmented Generation) application 
    that enables users to upload documents, organize them into rooms, and chat 
    with AI using document context entirely within the browser.

    Key Features:
    - Client-side document processing and vector embeddings
    - Multi-room organization with independent contexts
    - LLM model selection per room
    - IndexedDB storage for offline capability
    - No server-side processing required
    - Privacy-focused local execution

    Technical Stack:
    - Vanilla JavaScript with ES6 modules
    - Xenova/Transformers.js for embeddings
    - IndexedDB for local storage
    - OpenAI API integration
    - TailwindCSS for styling

    Copyright Notice:
    This software contains proprietary algorithms and implementations for 
    client-side RAG functionality. All rights reserved.
    ================================================================================
    -->
    <div class="flex h-screen">
        <!-- Sidebar -->
        <div class="sidebar text-white flex flex-col">
            <!-- Header -->
            <div class="p-6 border-b border-white border-opacity-20">
                <button id="new-room-btn" class="w-full bg-white bg-opacity-20 hover:bg-opacity-30 text-white font-semibold py-3 px-4 rounded-lg transition-all duration-200 flex items-center justify-center gap-2">
                    <i class="fas fa-plus"></i>
                    New Room
                </button>
            </div>
            
            <!-- Room List -->
            <div class="flex-1 overflow-y-auto">
                <div class="p-4">
                    <h3 class="text-sm font-semibold text-white text-opacity-80 mb-3 uppercase tracking-wide">Chat Rooms</h3>
                    <div id="room-list">
                        <!-- Rooms will be populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Chat Area -->
        <div class="chat-container">
            <!-- Chat Header -->
            <div class="bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <button id="mobile-menu-btn" class="md:hidden text-gray-600 hover:text-gray-800">
                        <i class="fas fa-bars"></i>
                    </button>
                    <h1 id="chat-title" class="text-xl font-semibold text-gray-800">Smart Document Workspace</h1>
                </div>
                <div class="flex items-center gap-3">
                    <button id="upload-docs-btn" class="btn btn-secondary flex items-center gap-2">
                        <i class="fas fa-upload"></i>
                        Upload Docs
                    </button>
                    <button id="doc-update-mode-btn" class="btn btn-primary flex items-center gap-2">
                        <i class="fas fa-edit"></i>
                        Update Mode
                    </button>
                    <button id="clear-history-btn" class="btn btn-secondary flex items-center gap-2">
                        <i class="fas fa-trash"></i>
                        Clear History
                    </button>
                    <button id="settings-btn" class="text-gray-600 hover:text-gray-800 p-2">
                        <i class="fas fa-cog"></i>
                    </button>
                </div>
            </div>
            
            <!-- Chat Messages -->
            <div id="chat-messages" class="chat-messages">
                <div class="welcome-screen">
                    <div class="welcome-icon">
                        <i class="fas fa-comments"></i>
                    </div>
                    <h2 class="welcome-title">Welcome to Smart Document Workspace</h2>
                    <p class="welcome-description">
                        Create a room and upload documents to start chatting with your AI assistant about your content. This commercial edition includes advanced features like temperature control, chunking optimization, and file memory.
                    </p>
                </div>
            </div>
            
            <!-- Chat Input -->
            <div class="chat-input-container">
                <div class="relative">
                    <textarea id="chat-input" class="chat-input" placeholder="Ask a question about your documents..." rows="1"></textarea>
                    <button id="send-button" class="send-button">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Room Modal -->
    <div id="new-room-modal" class="modal">
        <div class="modal-content">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-800">Create New Room</h2>
                <button id="close-new-room" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="form-group">
                <label class="form-label">Room Name</label>
                <input type="text" id="room-name" class="form-input" placeholder="Enter room name...">
            </div>
            
            <div class="form-group">
                <label class="form-label">AI Model</label>
                <select id="room-model" class="form-select">
                    <option value="">Select Model...</option>
                    <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                    <option value="gpt-4">gpt-4</option>
                    <option value="gpt-4-turbo">gpt-4-turbo</option>
                </select>
            </div>
            
            <div class="form-group">
                <label class="form-label">Temperature: <span id="temperature-value">0.7</span></label>
                <input type="range" id="temperature-slider" class="slider" min="0" max="2" step="0.1" value="0.7">
                <div class="flex justify-between text-sm text-gray-500 mt-2">
                    <span>Focused (0.0)</span>
                    <span>Balanced (1.0)</span>
                    <span>Creative (2.0)</span>
                </div>
                <p class="text-sm text-gray-600 mt-2">Lower values make responses more focused and deterministic, higher values increase creativity and randomness.</p>
            </div>
            
            <div class="flex gap-3 mt-6">
                <button id="create-room-btn" class="btn btn-primary flex-1">
                    <i class="fas fa-plus mr-2"></i>
                    Create Room
                </button>
                <button id="cancel-new-room" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- File Upload Modal -->
    <div id="file-upload-modal" class="modal">
        <div class="modal-content">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-800">Upload Documents</h2>
                <button id="close-file-upload" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="mb-4">
                <div class="flex items-center gap-2 text-sm text-gray-600 mb-2">
                    <i class="fas fa-info-circle"></i>
                    <span>Active Room:</span>
                    <span id="upload-room-name" class="font-semibold text-purple-600">None</span>
                </div>
            </div>
            
            <div class="mb-6">
                <h3 class="font-semibold text-gray-700 mb-2 flex items-center gap-2">
                    <i class="fas fa-history"></i>
                    Recent Files
                </h3>
                <div id="recent-files" class="text-sm text-gray-500">
                    No recent files
                </div>
            </div>
            
            <div id="file-drop-zone" class="file-drop-zone mb-4">
                <div class="text-center">
                    <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
                    <p class="text-gray-600 mb-2">Drag & drop files here or click to select</p>
                    <p class="text-sm text-gray-500">Supported formats: TXT, MD, PDF, DOCX (Max 10MB per file)</p>
                    <button id="select-files" class="btn btn-primary mt-4">
                        <i class="fas fa-file-plus mr-2"></i>
                        Select Files
                    </button>
                </div>
            </div>
            
            <input type="file" id="file-input" multiple accept=".txt,.pdf,.docx" style="display: none;">
            
            <div id="selected-files" class="file-list" style="display: none;">
                <h4 class="font-semibold text-gray-700 mb-2">Selected Files:</h4>
                <div id="file-items"></div>
            </div>
            
            <div id="upload-progress" style="display: none;">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                </div>
                <p id="progress-text" class="text-sm text-gray-600 text-center mt-2">Processing...</p>
            </div>
            
            <div class="flex gap-3 mt-6">
                <button id="upload-btn" class="btn btn-primary flex-1">
                    <i class="fas fa-upload mr-2"></i>
                    Process Documents
                </button>
                <button id="cancel-upload-btn" class="btn btn-secondary">Cancel</button>
            </div>
            
            <div class="mt-6 pt-6 border-t border-gray-200">
                <h4 class="font-semibold text-gray-700 mb-3">Processed Documents</h4>
                <div id="processed-documents" class="text-sm text-gray-500">
                    No documents processed
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-800">Advanced Settings</h2>
                <button id="close-settings" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- API Configuration -->
            <div class="settings-section">
                <h3 class="settings-title">
                    <i class="fas fa-key"></i>
                    API Configuration
                </h3>
                <div class="form-group">
                    <label class="form-label">OpenAI API Key</label>
                    <input type="text" id="settings-api-key" placeholder="sk-..." class="form-input" />
                    <p class="text-sm text-gray-500 mt-2">Your API key is stored locally and never sent to our servers</p>
                </div>
            </div>
            
            <!-- Model Management -->
            <div class="settings-section">
                <h3 class="settings-title">
                    <i class="fas fa-robot"></i>
                    Model Management
                </h3>
                <div class="form-group">
                    <label class="form-label">Available Models</label>
                    <div id="model-list">
                        <div class="model-item">
                            <span>gpt-3.5-turbo</span>
                            <button class="text-red-500 hover:text-red-700">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                        <div class="model-item">
                            <span>gpt-4</span>
                            <button class="text-red-500 hover:text-red-700">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                        <div class="model-item">
                            <span>gpt-4-turbo</span>
                            <button class="text-red-500 hover:text-red-700">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    <div class="flex gap-2 mt-3">
                        <input type="text" id="new-model-input" placeholder="e.g., gpt-4-turbo" class="form-input flex-1" />
                        <button id="add-model-btn" class="btn btn-primary">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Chunking Strategy -->
            <div class="settings-section">
                <h3 class="settings-title">
                    <i class="fas fa-puzzle-piece"></i>
                    Chunking Strategy
                </h3>
                <div class="form-group">
                    <label class="form-label">Strategy</label>
                    <select id="chunking-strategy" class="form-select">
                        <option value="semantic">Semantic Chunking</option>
                        <option value="sentence">Sentence-based</option>
                        <option value="fixed">Fixed Size</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Chunk Size: <span id="chunk-size-value">1000</span> characters</label>
                    <input type="range" id="chunk-size-slider" class="slider" min="200" max="2000" step="100" value="1000">
                    <div class="flex justify-between text-sm text-gray-500 mt-2">
                        <span>Small (200)</span>
                        <span>Large (2000)</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Overlap: <span id="overlap-value">200</span> characters</label>
                    <input type="range" id="overlap-slider" class="slider" min="0" max="500" step="50" value="200">
                    <div class="flex justify-between text-sm text-gray-500 mt-2">
                        <span>None (0)</span>
                        <span>High (500)</span>
                    </div>
                </div>
                <div class="bg-gray-50 p-3 rounded-lg mt-3">
                    <p class="text-sm text-gray-600">
                        <strong>Preview:</strong> This is a sample text to demonstrate how the chunking strategy works. The text will be split into smaller pieces based on the selected strategy and parameters. Semantic chunking tries to keep related content together, while fixed-size chunking splits at exact character counts.
                    </p>
                </div>
            </div>
            
            <!-- Performance -->
            <div class="settings-section">
                <h3 class="settings-title">
                    <i class="fas fa-tachometer-alt"></i>
                    Performance
                </h3>
                <div class="form-group">
                    <label class="form-label">Search Results: <span id="search-results-value">5</span></label>
                    <input type="range" id="search-results-slider" class="slider" min="1" max="10" step="1" value="5">
                    <div class="flex justify-between text-sm text-gray-500 mt-2">
                        <span>Fast (1)</span>
                        <span>Comprehensive (10)</span>
                    </div>
                </div>
                <div class="performance-grid">
                    <div class="performance-item">
                        <div id="documents-processed" class="performance-value">0</div>
                        <div class="performance-label">Documents Processed</div>
                    </div>
                    <div class="performance-item">
                        <div id="total-chunks" class="performance-value">0</div>
                        <div class="performance-label">Total Chunks</div>
                    </div>
                    <div class="performance-item">
                        <div id="memory-usage" class="performance-value">0 MB</div>
                        <div class="performance-label">Memory Usage</div>
                    </div>
                    <div class="performance-item">
                        <div id="avg-response-time" class="performance-value">0ms</div>
                        <div class="performance-label">Avg Response Time</div>
                    </div>
                </div>
            </div>
            
            <div class="flex gap-3 mt-6">
                <button id="save-settings-btn" class="btn btn-primary flex-1">
                    <i class="fas fa-save mr-2"></i>
                    Save Settings
                </button>
                <button id="export-settings-btn" class="btn btn-secondary">
                    <i class="fas fa-download mr-2"></i>
                    Export
                </button>
                <button id="import-settings-btn" class="btn btn-secondary">
                    <i class="fas fa-upload mr-2"></i>
                    Import
                </button>
            </div>
        </div>
    </div>
    
    <!-- Document Update Mode Modal -->
    <div id="doc-update-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-semibold text-gray-800">Document Update Mode</h2>
                <button id="close-doc-update" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- File Upload Section -->
            <div class="settings-section">
                <h3 class="settings-title">
                    <i class="fas fa-file-text"></i>
                    Upload Documents (TXT/MD only)
                </h3>
                <div id="doc-update-drop-zone" class="file-drop-zone mb-4">
                    <div class="text-center">
                        <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
                        <p class="text-gray-600 mb-2">Drag & drop TXT or MD files here or click to select</p>
                        <p class="text-sm text-gray-500">Only TXT and MD files are supported</p>
                        <button id="select-update-files" class="btn btn-primary mt-4">
                            <i class="fas fa-file-plus mr-2"></i>
                            Select Files
                        </button>
                    </div>
                </div>
                
                <input type="file" id="doc-update-file-input" multiple accept=".txt,.md" style="display: none;">
                
                <div id="selected-update-files" class="file-list" style="display: none;">
                    <h4 class="font-semibold text-gray-700 mb-2">Selected Files:</h4>
                    <div id="update-file-items"></div>
                </div>
            </div>
            
            <!-- New Information Section -->
            <div class="settings-section">
                <h3 class="settings-title">
                    <i class="fas fa-plus-circle"></i>
                    New Information/Facts
                </h3>
                <div class="form-group">
                    <label class="form-label">Enter new facts or events to update your documents:</label>
                    <textarea id="new-information-input" class="form-input" rows="6" 
                              placeholder="Example: JohnnyB had no creativity and always mimicked others."></textarea>
                    <p class="text-sm text-gray-500 mt-2">This information will be used to update the content of your documents.</p>
                </div>
            </div>
            
            <!-- Update Progress -->
            <div id="update-progress" style="display: none;">
                <div class="progress-bar">
                    <div id="update-progress-fill" class="progress-fill" style="width: 0%"></div>
                </div>
                <p id="update-progress-text" class="text-sm text-gray-600 text-center mt-2">Processing...</p>
            </div>
            
            <!-- Updated Documents Preview -->
            <div id="updated-documents-section" style="display: none;">
                <div class="settings-section">
                    <h3 class="settings-title">
                        <i class="fas fa-eye"></i>
                        Updated Documents Preview
                    </h3>
                    <div id="updated-documents-preview" class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                        <!-- Updated documents will be displayed here -->
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="flex gap-3 mt-6">
                <button id="update-documents-btn" class="btn btn-primary flex-1">
                    <i class="fas fa-magic mr-2"></i>
                    Update Documents
                </button>
                <button id="download-updated-btn" class="btn btn-secondary" style="display: none;">
                    <i class="fas fa-download mr-2"></i>
                    Download Updated Documents
                </button>
                <button id="cancel-doc-update" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        class SmartDocumentWorkspace {
            constructor() {
                this.currentRoom = null;
                this.rooms = [];
                this.vectorEngine = new VectorEngine();
                this.storage = new LocalStorage();
                this.openaiClient = null;
                this.openaiApiKey = '';
                this.settings = {
                    chunkingStrategy: 'semantic',
                    chunkSize: 1000,
                    overlap: 200,
                    searchResults: 5
                };
                this.performance = {
                    documentsProcessed: 0,
                    totalChunks: 0,
                    memoryUsage: 0,
                    avgResponseTime: 0
                };
                this.recentFiles = [];
                this.documentUpdateMode = new DocumentUpdateMode(this);
                
                this.init();
            }
            
            async init() {
                await this.loadSettings();
                await this.loadRooms();
                await this.loadRecentFiles();
                this.setupEventListeners();
                this.updatePerformanceDisplay();
                this.showNotification('Commercial application initialized successfully!', 'success');
            }
            
            setupEventListeners() {
                // Room management
                document.getElementById('new-room-btn').addEventListener('click', () => {
                    this.showNewRoomModal();
                });
                
                document.getElementById('close-new-room').addEventListener('click', () => {
                    this.hideNewRoomModal();
                });
                
                document.getElementById('cancel-new-room').addEventListener('click', () => {
                    this.hideNewRoomModal();
                });
                
                document.getElementById('create-room-btn').addEventListener('click', () => {
                    this.createRoom();
                });
                
                // Settings
                document.getElementById('settings-btn').addEventListener('click', () => {
                    this.showSettingsModal();
                });
                
                document.getElementById('close-settings').addEventListener('click', () => {
                    this.hideSettingsModal();
                });
                
                document.getElementById('save-settings-btn').addEventListener('click', () => {
                    this.saveSettings();
                });
                
                document.getElementById('export-settings-btn').addEventListener('click', () => {
                    this.exportSettings();
                });
                
                document.getElementById('import-settings-btn').addEventListener('click', () => {
                    this.importSettings();
                });
                
                // Temperature slider
                document.getElementById('temperature-slider').addEventListener('input', (e) => {
                    document.getElementById('temperature-value').textContent = e.target.value;
                });
                
                // Settings sliders
                document.getElementById('chunk-size-slider').addEventListener('input', (e) => {
                    document.getElementById('chunk-size-value').textContent = e.target.value;
                });
                
                document.getElementById('overlap-slider').addEventListener('input', (e) => {
                    document.getElementById('overlap-value').textContent = e.target.value;
                });
                
                document.getElementById('search-results-slider').addEventListener('input', (e) => {
                    document.getElementById('search-results-value').textContent = e.target.value;
                });
                
                // File upload modal
                document.getElementById('upload-docs-btn').addEventListener('click', () => {
                    this.showFileUploadModal();
                });
                
                document.getElementById('close-file-upload').addEventListener('click', () => {
                    this.hideFileUploadModal();
                });
                
                document.getElementById('cancel-upload-btn').addEventListener('click', () => {
                    this.hideFileUploadModal();
                });
                
                document.getElementById('select-files').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });
                
                document.getElementById('file-input').addEventListener('change', () => {
                    this.displaySelectedFiles();
                });
                
                document.getElementById('upload-btn').addEventListener('click', () => {
                    this.processDocuments();
                });
                
                // Document Update Mode
                document.getElementById('doc-update-mode-btn').addEventListener('click', () => {
                    this.documentUpdateMode.showModal();
                });
                
                // Chat - 日本語入力対応
                let isComposing = false;
                
                document.getElementById('chat-input').addEventListener('compositionstart', () => {
                    isComposing = true;
                });
                
                document.getElementById('chat-input').addEventListener('compositionend', () => {
                    isComposing = false;
                });
                
                document.getElementById('chat-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey && !isComposing) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                
                document.getElementById('send-button').addEventListener('click', () => {
                    this.sendMessage();
                });
                
                document.getElementById('clear-history-btn').addEventListener('click', () => {
                    this.clearChatHistory();
                });
                
                // Auto-resize textarea
                document.getElementById('chat-input').addEventListener('input', (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = Math.min(e.target.scrollHeight, 120) + 'px';
                });
                
                // Mobile menu
                document.getElementById('mobile-menu-btn').addEventListener('click', () => {
                    document.querySelector('.sidebar').classList.toggle('show');
                });
                
                // File drag and drop
                const dropZone = document.getElementById('file-drop-zone');
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    const files = Array.from(e.dataTransfer.files);
                    
                    // FileListを作成するためのDataTransferを使用
                    const dt = new DataTransfer();
                    files.forEach(file => dt.items.add(file));
                    document.getElementById('file-input').files = dt.files;
                    
                    this.displaySelectedFiles();
                }, false);
                
                // Modal click outside to close
                document.getElementById('settings-modal').addEventListener('click', (e) => {
                    if (e.target === e.currentTarget) {
                        this.hideSettingsModal();
                    }
                });
                
                document.getElementById('new-room-modal').addEventListener('click', (e) => {
                    if (e.target === e.currentTarget) {
                        this.hideNewRoomModal();
                    }
                });
                
                document.getElementById('file-upload-modal').addEventListener('click', (e) => {
                    if (e.target === e.currentTarget) {
                        this.hideFileUploadModal();
                    }
                });
            }
            
            // Room Management
            showNewRoomModal() {
                document.getElementById('new-room-modal').classList.add('show');
                document.getElementById('room-name').focus();
            }
            
            hideNewRoomModal() {
                document.getElementById('new-room-modal').classList.remove('show');
                document.getElementById('room-name').value = '';
                document.getElementById('room-model').value = '';
                document.getElementById('temperature-slider').value = '0.7';
                document.getElementById('temperature-value').textContent = '0.7';
            }
            
            async createRoom() {
                const name = document.getElementById('room-name').value.trim();
                const model = document.getElementById('room-model').value;
                const temperature = parseFloat(document.getElementById('temperature-slider').value);
                
                if (!name || !model) {
                    this.showNotification('Please fill in all fields', 'error');
                    return;
                }
                
                const room = {
                    id: Date.now().toString(),
                    name,
                    model,
                    temperature,
                    created_at: new Date().toISOString(),
                    chat_count: 0
                };
                
                this.rooms.push(room);
                await this.storage.saveRoom(room);
                this.updateRoomList();
                this.selectRoom(room);
                this.hideNewRoomModal();
                this.showNotification(`Room "${name}" created successfully!`, 'success');
            }
            
            async deleteRoom(roomId) {
                if (confirm('Are you sure you want to delete this room?')) {
                    this.rooms = this.rooms.filter(room => room.id !== roomId);
                    await this.storage.deleteRoom(roomId);
                    
                    if (this.currentRoom && this.currentRoom.id === roomId) {
                        this.currentRoom = null;
                        this.clearChatDisplay();
                    }
                    
                    this.updateRoomList();
                    this.showNotification('Room deleted successfully', 'success');
                }
            }
            
            selectRoom(room) {
                // Save current room vectors before switching
                if (this.currentRoom && this.vectorEngine.vectors.length > 0) {
                    this.saveCurrentRoomVectors();
                }
                
                this.currentRoom = room;
                this.updateRoomList();
                this.loadChatHistory();
                document.getElementById('chat-title').textContent = room.name;
                document.getElementById('upload-room-name').textContent = room.name;
                
                // Hide welcome screen
                const welcomeScreen = document.querySelector('.welcome-screen');
                if (welcomeScreen) {
                    welcomeScreen.style.display = 'none';
                }
                
                // Load room-specific vectors
                this.loadRoomVectors(room.id);
            }

            async saveCurrentRoomVectors() {
                if (this.currentRoom && this.vectorEngine.vectors.length > 0) {
                    try {
                        await this.storage.saveVectors(this.currentRoom.id, {
                            vectors: this.vectorEngine.vectors,
                            timestamp: Date.now()
                        });
                    } catch (error) {
                        console.error('Failed to save room vectors:', error);
                    }
                }
            }

            async loadRoomVectors(roomId) {
                try {
                    const vectorData = await this.storage.getVectors(roomId);
                    if (vectorData) {
                        this.vectorEngine.loadVectors(vectorData);
                    } else {
                        this.vectorEngine.clearVectors();
                    }
                } catch (error) {
                    console.error('Failed to load room vectors:', error);
                    this.vectorEngine.clearVectors();
                }
            }
            
            updateRoomList() {
                const roomList = document.getElementById('room-list');
                roomList.innerHTML = '';
                
                this.rooms.forEach(room => {
                    const roomElement = document.createElement('div');
                    roomElement.className = `room-item ${this.currentRoom && this.currentRoom.id === room.id ? 'active' : ''}`;
                    roomElement.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div class="flex-1 cursor-pointer" onclick="workspace.selectRoom(${JSON.stringify(room).replace(/"/g, '&quot;')})">
                                <div class="room-name">${room.name}</div>
                                <div class="room-details">${room.model} • T:${room.temperature}</div>
                            </div>
                            <button onclick="workspace.deleteRoom('${room.id}')" class="text-white text-opacity-60 hover:text-opacity-100 p-1">
                                <i class="fas fa-trash text-sm"></i>
                            </button>
                        </div>
                    `;
                    roomList.appendChild(roomElement);
                });
            }
            
            // Settings Management
            showSettingsModal() {
                document.getElementById('settings-modal').classList.add('show');
                this.loadSettingsToModal();
            }
            
            hideSettingsModal() {
                document.getElementById('settings-modal').classList.remove('show');
            }
            
            loadSettingsToModal() {
                document.getElementById('settings-api-key').value = this.openaiApiKey;
                document.getElementById('chunking-strategy').value = this.settings.chunkingStrategy;
                document.getElementById('chunk-size-slider').value = this.settings.chunkSize;
                document.getElementById('chunk-size-value').textContent = this.settings.chunkSize;
                document.getElementById('overlap-slider').value = this.settings.overlap;
                document.getElementById('overlap-value').textContent = this.settings.overlap;
                document.getElementById('search-results-slider').value = this.settings.searchResults;
                document.getElementById('search-results-value').textContent = this.settings.searchResults;
            }
            
            async saveSettings() {
                this.openaiApiKey = document.getElementById('settings-api-key').value;
                this.settings.chunkingStrategy = document.getElementById('chunking-strategy').value;
                this.settings.chunkSize = parseInt(document.getElementById('chunk-size-slider').value);
                this.settings.overlap = parseInt(document.getElementById('overlap-slider').value);
                this.settings.searchResults = parseInt(document.getElementById('search-results-slider').value);
                
                if (this.openaiApiKey) {
                    this.openaiClient = new OpenAI({
                        apiKey: this.openaiApiKey,
                        dangerouslyAllowBrowser: true
                    });
                }
                
                await this.storage.saveSettings({
                    apiKey: this.openaiApiKey,
                    settings: this.settings
                });
                
                this.hideSettingsModal();
                this.showNotification('Settings saved successfully!', 'success');
            }
            
            async loadSettings() {
                try {
                    const saved = await this.storage.loadSettings();
                    if (saved) {
                        this.openaiApiKey = saved.apiKey || '';
                        this.settings = { ...this.settings, ...saved.settings };
                        
                        if (this.openaiApiKey) {
                            this.openaiClient = new OpenAI({
                                apiKey: this.openaiApiKey,
                                dangerouslyAllowBrowser: true
                            });
                        }
                    }
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
            }
            
            exportSettings() {
                const data = {
                    settings: this.settings,
                    rooms: this.rooms,
                    recentFiles: this.recentFiles
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'smart-workspace-settings.json';
                a.click();
                URL.revokeObjectURL(url);
                
                this.showNotification('Settings exported successfully!', 'success');
            }
            
            importSettings() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            const text = await file.text();
                            const data = JSON.parse(text);
                            
                            if (data.settings) {
                                this.settings = { ...this.settings, ...data.settings };
                            }
                            if (data.rooms) {
                                this.rooms = data.rooms;
                                this.updateRoomList();
                            }
                            if (data.recentFiles) {
                                this.recentFiles = data.recentFiles;
                            }
                            
                            await this.saveSettings();
                            this.showNotification('Settings imported successfully!', 'success');
                        } catch (error) {
                            this.showNotification('Failed to import settings', 'error');
                        }
                    }
                };
                input.click();
            }
            
            // File Management
            showFileUploadModal() {
                if (!this.currentRoom) {
                    this.showNotification('Please select a room first', 'error');
                    return;
                }
                
                document.getElementById('file-upload-modal').classList.add('show');
                document.getElementById('upload-room-name').textContent = this.currentRoom.name;
                this.displayRecentFiles();
            }
            
            showFileUploadModal() {
                document.getElementById('file-upload-modal').classList.add('show');
                this.updateRecentFilesDisplay(); // Recent Filesを更新
            }
            
            hideFileUploadModal() {
                document.getElementById('file-upload-modal').classList.remove('show');
                document.getElementById('file-input').value = '';
                document.getElementById('selected-files').style.display = 'none';
                document.getElementById('upload-progress').style.display = 'none';
            }
            
            displaySelectedFiles() {
                const files = Array.from(document.getElementById('file-input').files);
                const container = document.getElementById('selected-files');
                const itemsContainer = document.getElementById('file-items');
                
                if (files.length === 0) {
                    container.style.display = 'none';
                    return;
                }
                
                container.style.display = 'block';
                itemsContainer.innerHTML = '';
                
                files.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <div class="flex-1">
                            <div class="font-medium">${file.name}</div>
                            <div class="text-sm text-gray-500">${this.formatFileSize(file.size)}</div>
                        </div>
                        <button onclick="window.workspace.removeSelectedFile(${index})" class="text-red-500 hover:text-red-700">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    itemsContainer.appendChild(item);
                });
            }
            
            displayRecentFiles() {
                const container = document.getElementById('recent-files');
                
                if (this.recentFiles.length === 0) {
                    container.innerHTML = '<div class="text-sm text-gray-500">No recent files</div>';
                    return;
                }
                
                container.innerHTML = this.recentFiles.map(file => `
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded mb-2">
                        <div class="flex-1">
                            <div class="font-medium text-sm">${file.name}</div>
                            <div class="text-xs text-gray-500">${new Date(file.uploadedAt).toLocaleDateString()}</div>
                        </div>
                        <button onclick="workspace.reuseFile('${file.path}')" class="text-blue-500 hover:text-blue-700 text-sm">
                            <i class="fas fa-plus"></i> Use
                        </button>
                    </div>
                `).join('');
            }
            
            async reuseFile(filePath) {
                try {
                    // In a real implementation, you would load the file from the stored path
                    this.showNotification('File reuse feature would load from: ' + filePath, 'success');
                } catch (error) {
                    this.showNotification('Failed to reuse file', 'error');
                }
            }
            
            async processDocuments() {
                const files = Array.from(document.getElementById('file-input').files);
                
                if (files.length === 0) {
                    this.showNotification('Please select files first', 'error');
                    return;
                }
                
                document.getElementById('upload-progress').style.display = 'block';
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');
                
                try {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const progress = ((i + 1) / files.length) * 100;
                        
                        progressFill.style.width = progress + '%';
                        progressText.textContent = `Processing ${file.name}... (${i + 1}/${files.length})`;
                        
                        const content = await this.extractFileContent(file);
                        await this.vectorEngine.addDocument({
                            id: Date.now() + '_' + i,
                            title: file.name,
                            content: content,
                            metadata: {
                                filename: file.name,
                                size: file.size,
                                type: file.type,
                                uploadedAt: new Date().toISOString()
                            }
                        }, this.settings);
                        
                        // Add to recent files with room ID and content
                        this.recentFiles.unshift({
                            name: file.name,
                            path: file.name, // In real implementation, this would be a proper file path
                            uploadedAt: new Date().toISOString(),
                            roomId: this.currentRoom.id, // ルームIDを追加
                            content: content, // ファイル内容を保存
                            size: file.size,
                            type: file.type
                        });
                        
                        // Keep only last 10 recent files
                        this.recentFiles = this.recentFiles.slice(0, 10);
                    }
                    
                    // Save vectors to storage after processing all files
                    await this.storage.saveVectors(this.currentRoom.id, {
                        vectors: this.vectorEngine.vectors,
                        timestamp: Date.now()
                    });
                    
                    await this.storage.saveRecentFiles(this.recentFiles);
                    this.performance.documentsProcessed += files.length;
                    this.performance.totalChunks = this.vectorEngine.vectors.length;
                    this.updatePerformanceDisplay();
                    
                    this.showNotification(`Successfully processed ${files.length} document(s)!`, 'success');
                    this.hideFileUploadModal();
                    
                } catch (error) {
                    console.error('Error processing documents:', error);
                    this.showNotification('Failed to process documents', 'error');
                } finally {
                    document.getElementById('upload-progress').style.display = 'none';
                }
            }
            
            async extractFileContent(file) {
                const fileType = file.type || file.name.split('.').pop().toLowerCase();
                
                if (fileType.includes('text') || fileType === 'txt') {
                    return await this.readTextFile(file);
                } else if (fileType.includes('pdf')) {
                    return await this.readPDFFile(file);
                } else if (fileType.includes('wordprocessingml') || fileType === 'docx') {
                    return await this.readDocxFile(file);
                } else {
                    throw new Error(`Unsupported file type: ${fileType}`);
                }
            }
            
            async readTextFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            async readPDFFile(file) {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                let text = '';
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    text += pageText + '\n';
                }
                
                return text;
            }
            
            async readDocxFile(file) {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                return result.value;
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            // Chat Management
            async sendMessage() {
                if (!this.currentRoom) {
                    this.showNotification('Please select a room first.', 'error');
                    return;
                }

                const chatInput = document.getElementById('chat-input');
                const query = chatInput.value.trim();
                
                if (!query) return;

                chatInput.value = '';
                chatInput.style.height = 'auto';
                const sendBtn = document.getElementById('send-button');
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                const userMessage = {
                    sender: 'user',
                    message: query,
                    timestamp: new Date().toISOString()
                };

                this.addMessageToChat(userMessage.sender, userMessage.message, userMessage.timestamp);
                await this.storage.saveChatHistory(this.currentRoom.id, userMessage);

                try {
                    let context = '';
                    
                    // 文書が処理されている場合のみRAG検索を実行
                    if (this.vectorEngine.vectors.length > 0) {
                        const searchResults = await this.vectorEngine.search(query, this.settings.searchResults);
                        context = searchResults.map(result => result.text).join('\n\n');
                    }

                    const response = await this.openaiClient.chat.completions.create({
                        model: this.currentRoom.model,
                        messages: [
                            {
                                role: 'system',
                                content: context ? 
                                    `You are a helpful assistant. Use the following context to answer questions when relevant:\n\n${context}` :
                                    'You are a helpful assistant. Answer questions to the best of your ability.'
                            },
                            { role: 'user', content: query }
                        ],
                        temperature: this.currentRoom.temperature,
                        max_tokens: 1000
                    });

                    const assistantMessage = {
                        sender: 'assistant',
                        message: response.choices[0].message.content,
                        timestamp: new Date().toISOString()
                    };

                    this.addMessageToChat(assistantMessage.sender, assistantMessage.message, assistantMessage.timestamp);
                    await this.storage.saveChatHistory(this.currentRoom.id, assistantMessage);

                } catch (error) {
                    console.error('Error sending message:', error);
                    this.showNotification('Failed to send message. Please check your API key and try again.', 'error');
                } finally {
                    sendBtn.disabled = false;
                    sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                }
            }
            
            addMessageToChat(sender, message, timestamp) {
                const chatMessages = document.getElementById('chat-messages');
                
                // Hide welcome screen if it's still visible
                const welcomeScreen = chatMessages.querySelector('.welcome-screen');
                if (welcomeScreen) {
                    welcomeScreen.style.display = 'none';
                }
                
                const messageElement = document.createElement('div');
                messageElement.className = `message-bubble message-${sender}`;
                
                const time = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                messageElement.innerHTML = `
                    <div class="message-content">${this.formatMessage(message)}</div>
                    <div class="text-xs opacity-70 mt-1">${time}</div>
                `;
                
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            formatMessage(message) {
                // Basic markdown-like formatting
                return message
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px;">$1</code>')
                    .replace(/\n/g, '<br>');
            }
            
            addTypingIndicator() {
                const chatMessages = document.getElementById('chat-messages');
                const typingElement = document.createElement('div');
                typingElement.className = 'typing-indicator';
                typingElement.id = 'typing-indicator';
                typingElement.innerHTML = `
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                `;
                chatMessages.appendChild(typingElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            removeTypingIndicator() {
                const typingIndicator = document.getElementById('typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }
            
            async clearChatHistory() {
                if (!this.currentRoom) return;
                
                if (confirm('Are you sure you want to clear the chat history?')) {
                    await this.storage.clearChatHistory(this.currentRoom.id);
                    this.clearChatDisplay();
                    this.showNotification('Chat history cleared', 'success');
                }
            }
            
            clearChatDisplay() {
                const chatMessages = document.getElementById('chat-messages');
                chatMessages.innerHTML = `
                    <div class="welcome-screen">
                        <div class="welcome-icon">
                            <i class="fas fa-comments"></i>
                        </div>
                        <h2 class="welcome-title">Welcome to Smart Document Workspace</h2>
                        <p class="welcome-description">
                            Create a room and upload documents to start chatting with your AI assistant about your content. This commercial edition includes advanced features like temperature control, chunking optimization, and file memory.
                        </p>
                    </div>
                `;
            }
            
            async loadChatHistory() {
                if (!this.currentRoom) return;
                
                try {
                    const history = await this.storage.loadChatHistory(this.currentRoom.id);
                    const chatMessages = document.getElementById('chat-messages');
                    chatMessages.innerHTML = '';
                    
                    if (history.length === 0) {
                        this.clearChatDisplay();
                        return;
                    }
                    
                    history.forEach(msg => {
                        this.addMessageToChat(msg.sender, msg.message, msg.timestamp);
                    });
                } catch (error) {
                    console.error('Failed to load chat history:', error);
                }
            }
            
            // Storage and Data Management
            async loadRooms() {
                try {
                    this.rooms = await this.storage.loadRooms();
                    this.updateRoomList();
                } catch (error) {
                    console.error('Failed to load rooms:', error);
                }
            }
            
            updateRecentFilesDisplay() {
                const container = document.getElementById('recent-files');
                if (!container) return;

                // 現在のルームのファイルのみフィルタリング
                const roomFiles = this.recentFiles.filter(file => 
                    file.roomId === this.currentRoom?.id
                );

                if (roomFiles.length === 0) {
                    container.innerHTML = '<div class="text-gray-500 text-sm">No recent files for this room</div>';
                    return;
                }

                container.innerHTML = roomFiles.map(file => `
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded mb-2">
                        <div class="flex-1">
                            <div class="font-medium text-sm">${file.name}</div>
                            <div class="text-xs text-gray-500">${new Date(file.uploadedAt).toLocaleDateString()}</div>
                        </div>
                        <button class="btn btn-sm btn-primary" onclick="window.workspace.useRecentFile('${file.path}', '${file.name}')" style="background: #6366f1; color: white; padding: 4px 8px; border-radius: 4px; border: none; cursor: pointer;">
                            + Use
                        </button>
                    </div>
                `).join('');
            }
            
            async useRecentFile(filePath, fileName) {
                try {
                    // Recent Filesから実際のファイル内容を取得
                    const recentFile = this.recentFiles.find(f => f.name === fileName && f.path === filePath);
                    if (!recentFile || !recentFile.content) {
                        this.showNotification('File content not found in recent files', 'error');
                        return;
                    }
                    
                    // ファイルを選択リストに追加
                    const fileInput = document.getElementById('file-input');
                    const dt = new DataTransfer();
                    
                    // 既存のファイルを保持
                    Array.from(fileInput.files).forEach(file => dt.items.add(file));
                    
                    // Recent Fileから実際のファイル内容でFileオブジェクトを作成
                    const fileContent = recentFile.content;
                    const mimeType = this.getMimeType(fileName);
                    const actualFile = new File([fileContent], fileName, { type: mimeType });
                    dt.items.add(actualFile);
                    
                    // ファイル入力を更新
                    fileInput.files = dt.files;
                    
                    this.showNotification(`Added "${fileName}" to upload queue`, 'success');
                    
                    // ファイル選択表示を更新
                    this.displaySelectedFiles();
                } catch (error) {
                    console.error('Error using recent file:', error);
                    this.showNotification('Failed to add recent file', 'error');
                }
            }
            
            getMimeType(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                const mimeTypes = {
                    'txt': 'text/plain',
                    'pdf': 'application/pdf',
                    'doc': 'application/msword',
                    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'md': 'text/markdown',
                    'html': 'text/html',
                    'json': 'application/json'
                };
                return mimeTypes[extension] || 'text/plain';
            }
            
            removeSelectedFile(index) {
                try {
                    const fileInput = document.getElementById('file-input');
                    const dt = new DataTransfer();
                    
                    // 指定されたインデックス以外のファイルを保持
                    Array.from(fileInput.files).forEach((file, i) => {
                        if (i !== index) {
                            dt.items.add(file);
                        }
                    });
                    
                    // ファイル入力を更新
                    fileInput.files = dt.files;
                    
                    // ファイル選択表示を更新
                    this.displaySelectedFiles();
                    
                    this.showNotification('File removed from upload queue', 'success');
                } catch (error) {
                    console.error('Error removing file:', error);
                    this.showNotification('Failed to remove file', 'error');
                }
            }
            
            async loadRecentFiles() {
                try {
                    this.recentFiles = await this.storage.loadRecentFiles() || [];
                } catch (error) {
                    console.error('Failed to load recent files:', error);
                }
            }
            
            // Utility Methods
            updatePerformanceDisplay() {
                document.getElementById('documents-processed').textContent = this.performance.documentsProcessed;
                document.getElementById('total-chunks').textContent = this.performance.totalChunks;
                document.getElementById('memory-usage').textContent = this.performance.memoryUsage + ' MB';
                document.getElementById('avg-response-time').textContent = this.performance.avgResponseTime + 'ms';
            }
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }
        }
        
        // Vector Engine for RAG
        class VectorEngine {
            constructor() {
                this.vectors = [];
                this.model = null;
                this.initModel();
            }
            
            async initModel() {
                try {
                    // Initialize the embedding model
                    this.model = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
                } catch (error) {
                    console.error('Failed to initialize embedding model:', error);
                }
            }
            
            async addDocument(document, settings) {
                const chunks = this.chunkDocument(document.content, settings);
                
                for (let i = 0; i < chunks.length; i++) {
                    const chunk = chunks[i];
                    const embedding = await this.getEmbedding(chunk);
                    
                    this.vectors.push({
                        id: `${document.id}_chunk_${i}`,
                        text: chunk,
                        embedding: embedding,
                        document: document,
                        metadata: {
                            ...document.metadata,
                            chunkIndex: i,
                            chunkText: chunk
                        }
                    });
                }
            }
            
            chunkDocument(text, settings) {
                const { chunkingStrategy, chunkSize, overlap } = settings;
                
                switch (chunkingStrategy) {
                    case 'semantic':
                        return this.semanticChunking(text, chunkSize, overlap);
                    case 'sentence':
                        return this.sentenceChunking(text, chunkSize, overlap);
                    case 'fixed':
                    default:
                        return this.fixedChunking(text, chunkSize, overlap);
                }
            }
            
            fixedChunking(text, chunkSize, overlap) {
                const chunks = [];
                let start = 0;
                
                while (start < text.length) {
                    const end = Math.min(start + chunkSize, text.length);
                    chunks.push(text.slice(start, end));
                    start = end - overlap;
                    
                    if (start >= text.length) break;
                }
                
                return chunks;
            }
            
            sentenceChunking(text, chunkSize, overlap) {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const chunks = [];
                let currentChunk = '';
                
                for (const sentence of sentences) {
                    if (currentChunk.length + sentence.length > chunkSize && currentChunk.length > 0) {
                        chunks.push(currentChunk.trim());
                        currentChunk = sentence;
                    } else {
                        currentChunk += (currentChunk ? '. ' : '') + sentence;
                    }
                }
                
                if (currentChunk.trim().length > 0) {
                    chunks.push(currentChunk.trim());
                }
                
                return chunks;
            }
            
            semanticChunking(text, chunkSize, overlap) {
                // Simplified semantic chunking - in a real implementation, 
                // this would use more sophisticated NLP techniques
                const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 0);
                const chunks = [];
                let currentChunk = '';
                
                for (const paragraph of paragraphs) {
                    if (currentChunk.length + paragraph.length > chunkSize && currentChunk.length > 0) {
                        chunks.push(currentChunk.trim());
                        currentChunk = paragraph;
                    } else {
                        currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
                    }
                }
                
                if (currentChunk.trim().length > 0) {
                    chunks.push(currentChunk.trim());
                }
                
                return chunks;
            }
            
            async getEmbedding(text) {
                if (!this.model) {
                    // Fallback to simple hash-based embedding
                    return this.simpleEmbedding(text);
                }
                
                try {
                    const output = await this.model(text, { pooling: 'mean', normalize: true });
                    return Array.from(output.data);
                } catch (error) {
                    console.error('Error generating embedding:', error);
                    return this.simpleEmbedding(text);
                }
            }
            
            simpleEmbedding(text) {
                // Simple hash-based embedding as fallback
                const words = text.toLowerCase().split(/\s+/);
                const embedding = new Array(384).fill(0);
                
                words.forEach((word, index) => {
                    const hash = this.simpleHash(word);
                    embedding[hash % 384] += 1;
                });
                
                // Normalize
                const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
                return embedding.map(val => magnitude > 0 ? val / magnitude : 0);
            }
            
            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            async search(query, topK = 5) {
                if (this.vectors.length === 0) return [];
                
                const queryEmbedding = await this.getEmbedding(query);
                const similarities = this.vectors.map(vector => ({
                    ...vector,
                    similarity: this.cosineSimilarity(queryEmbedding, vector.embedding)
                }));
                
                return similarities
                    .sort((a, b) => b.similarity - a.similarity)
                    .slice(0, topK);
            }
            
            clearVectors() {
                this.vectors = [];
            }

            loadVectors(vectorData) {
                this.clearVectors();
                if (vectorData && vectorData.vectors) {
                    this.vectors = vectorData.vectors || [];
                }
            }

            cosineSimilarity(a, b) {
                const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
                const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
                const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
                
                if (magnitudeA === 0 || magnitudeB === 0) return 0;
                return dotProduct / (magnitudeA * magnitudeB);
            }
        }
        
        // Local Storage Manager
        class LocalStorage {
            constructor() {
                this.prefix = 'smart_workspace_';
            }
            
            async saveRoom(room) {
                const rooms = await this.loadRooms();
                const existingIndex = rooms.findIndex(r => r.id === room.id);
                
                if (existingIndex >= 0) {
                    rooms[existingIndex] = room;
                } else {
                    rooms.push(room);
                }
                
                localStorage.setItem(this.prefix + 'rooms', JSON.stringify(rooms));
            }
            
            async loadRooms() {
                const data = localStorage.getItem(this.prefix + 'rooms');
                return data ? JSON.parse(data) : [];
            }
            
            async deleteRoom(roomId) {
                const rooms = await this.loadRooms();
                const filtered = rooms.filter(r => r.id !== roomId);
                localStorage.setItem(this.prefix + 'rooms', JSON.stringify(filtered));
                
                // Also delete chat history for this room
                localStorage.removeItem(this.prefix + 'chat_' + roomId);
            }
            
            async saveChatHistory(roomId, message) {
                const history = await this.loadChatHistory(roomId);
                history.push(message);
                localStorage.setItem(this.prefix + 'chat_' + roomId, JSON.stringify(history));
            }
            
            async loadChatHistory(roomId) {
                const data = localStorage.getItem(this.prefix + 'chat_' + roomId);
                return data ? JSON.parse(data) : [];
            }
            
            async clearChatHistory(roomId) {
                localStorage.removeItem(this.prefix + 'chat_' + roomId);
            }
            
            async saveSettings(settings) {
                localStorage.setItem(this.prefix + 'settings', JSON.stringify(settings));
            }
            
            async loadSettings() {
                const data = localStorage.getItem(this.prefix + 'settings');
                return data ? JSON.parse(data) : null;
            }
            
            async saveVectors(roomId, vectorData) {
                localStorage.setItem(this.prefix + 'vectors_' + roomId, JSON.stringify(vectorData));
            }
            
            async getVectors(roomId) {
                const data = localStorage.getItem(this.prefix + 'vectors_' + roomId);
                return data ? JSON.parse(data) : null;
            }
            
            async saveRecentFiles(files) {
                localStorage.setItem(this.prefix + 'recent_files', JSON.stringify(files));
            }
            
            async loadRecentFiles() {
                const data = localStorage.getItem(this.prefix + 'recent_files');
                return data ? JSON.parse(data) : [];
            }
        }
        
        // OpenAI Client (simplified)
        class OpenAI {
            constructor(config) {
                this.apiKey = config.apiKey;
                this.baseURL = 'https://api.openai.com/v1';
            }
            
            get chat() {
                return {
                    completions: {
                        create: async (params) => {
                            const response = await fetch(`${this.baseURL}/chat/completions`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${this.apiKey}`
                                },
                                body: JSON.stringify(params)
                            });
                            
                            if (!response.ok) {
                                throw new Error(`OpenAI API error: ${response.status}`);
                            }
                            
                            return await response.json();
                        }
                    }
                };
            }
        }
        
        // Document Update Mode Class
        class DocumentUpdateMode {
            constructor(workspace) {
                this.workspace = workspace;
                this.selectedFiles = [];
                this.updatedDocuments = [];
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Modal controls
                document.getElementById('close-doc-update').addEventListener('click', () => {
                    this.hideModal();
                });
                
                document.getElementById('cancel-doc-update').addEventListener('click', () => {
                    this.hideModal();
                });
                
                // File selection
                document.getElementById('select-update-files').addEventListener('click', () => {
                    document.getElementById('doc-update-file-input').click();
                });
                
                document.getElementById('doc-update-file-input').addEventListener('change', () => {
                    this.handleFileSelection();
                });
                
                // Update documents
                document.getElementById('update-documents-btn').addEventListener('click', () => {
                    this.updateDocuments();
                });
                
                // Download updated documents
                document.getElementById('download-updated-btn').addEventListener('click', () => {
                    this.downloadUpdatedDocuments();
                });
                
                // Drag and drop
                const dropZone = document.getElementById('doc-update-drop-zone');
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    const files = Array.from(e.dataTransfer.files);
                    
                    // Filter only TXT and MD files
                    const validFiles = files.filter(file => {
                        const extension = file.name.split('.').pop().toLowerCase();
                        return extension === 'txt' || extension === 'md';
                    });
                    
                    if (validFiles.length !== files.length) {
                        this.workspace.showNotification('Only TXT and MD files are supported', 'error');
                    }
                    
                    if (validFiles.length > 0) {
                        const dt = new DataTransfer();
                        validFiles.forEach(file => dt.items.add(file));
                        document.getElementById('doc-update-file-input').files = dt.files;
                        this.handleFileSelection();
                    }
                });
                
                // Modal click outside to close
                document.getElementById('doc-update-modal').addEventListener('click', (e) => {
                    if (e.target === e.currentTarget) {
                        this.hideModal();
                    }
                });
            }
            
            showModal() {
                if (!this.workspace.openaiApiKey) {
                    this.workspace.showNotification('Please configure your OpenAI API key in settings first', 'error');
                    return;
                }
                
                document.getElementById('doc-update-modal').classList.add('show');
                this.resetModal();
            }
            
            hideModal() {
                document.getElementById('doc-update-modal').classList.remove('show');
                this.resetModal();
            }
            
            resetModal() {
                // Reset file input
                document.getElementById('doc-update-file-input').value = '';
                document.getElementById('selected-update-files').style.display = 'none';
                
                // Reset new information input
                document.getElementById('new-information-input').value = '';
                
                // Hide progress and results
                document.getElementById('update-progress').style.display = 'none';
                document.getElementById('updated-documents-section').style.display = 'none';
                document.getElementById('download-updated-btn').style.display = 'none';
                
                // Reset internal state
                this.selectedFiles = [];
                this.updatedDocuments = [];
            }
            
            handleFileSelection() {
                const files = Array.from(document.getElementById('doc-update-file-input').files);
                this.selectedFiles = files;
                
                if (files.length === 0) {
                    document.getElementById('selected-update-files').style.display = 'none';
                    return;
                }
                
                // Display selected files
                const container = document.getElementById('selected-update-files');
                const itemsContainer = document.getElementById('update-file-items');
                
                container.style.display = 'block';
                itemsContainer.innerHTML = '';
                
                files.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <div class="flex-1">
                            <div class="font-medium">${file.name}</div>
                            <div class="text-sm text-gray-500">${this.formatFileSize(file.size)}</div>
                        </div>
                        <button onclick="window.workspace.documentUpdateMode.removeFile(${index})" class="text-red-500 hover:text-red-700">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    itemsContainer.appendChild(item);
                });
            }
            
            removeFile(index) {
                const dt = new DataTransfer();
                Array.from(document.getElementById('doc-update-file-input').files).forEach((file, i) => {
                    if (i !== index) {
                        dt.items.add(file);
                    }
                });
                document.getElementById('doc-update-file-input').files = dt.files;
                this.handleFileSelection();
            }
            
            async updateDocuments() {
                const files = this.selectedFiles;
                const newInformation = document.getElementById('new-information-input').value.trim();
                
                if (files.length === 0) {
                    this.workspace.showNotification('Please select at least one file', 'error');
                    return;
                }
                
                if (!newInformation) {
                    this.workspace.showNotification('Please enter new information', 'error');
                    return;
                }
                
                // Show progress
                document.getElementById('update-progress').style.display = 'block';
                const progressFill = document.getElementById('update-progress-fill');
                const progressText = document.getElementById('update-progress-text');
                
                this.updatedDocuments = [];
                
                try {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const progress = ((i + 1) / files.length) * 100;
                        
                        progressFill.style.width = progress + '%';
                        progressText.textContent = `Processing ${file.name}... (${i + 1}/${files.length})`;
                        
                        // Read file content
                        const originalContent = await this.readFileContent(file);
                        
                        // Create prompt for LLM
                        const prompt = this.createUpdatePrompt(newInformation, originalContent);
                        
                        // Call OpenAI API
                        const updatedContent = await this.callOpenAI(prompt);
                        
                        // Store updated document
                        this.updatedDocuments.push({
                            originalName: file.name,
                            originalContent: originalContent,
                            updatedContent: updatedContent,
                            newInformation: newInformation
                        });
                    }
                    
                    // Hide progress and show results
                    document.getElementById('update-progress').style.display = 'none';
                    this.displayUpdatedDocuments();
                    
                    this.workspace.showNotification(`Successfully updated ${files.length} document(s)!`, 'success');
                    
                } catch (error) {
                    console.error('Error updating documents:', error);
                    this.workspace.showNotification('Failed to update documents: ' + error.message, 'error');
                    document.getElementById('update-progress').style.display = 'none';
                }
            }
            
            async readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            createUpdatePrompt(newInformation, documentContent) {
                return `Please update the following document based on new facts provided.

Instructions:

1. Keep the original language of the document unchanged (e.g., if it's in English, the output should remain in English).

2. You may interpret the new facts written in any language, but apply them to update the document in its original language.

3. Preserve the format and structure of the document (headings, bullet points, numbering, etc.).

4. Replace outdated or incorrect information based on the new facts.

5. Remove obsolete content that contradicts the updated facts.

6. Ensure internal consistency across all sections.

7. Do not add any commentary—just return the fully updated document only.

Original Document:
${documentContent}

New Facts:
${newInformation}`;

            }
            
            async callOpenAI(prompt) {
                const response = await this.workspace.openaiClient.chat.completions.create({
                    model: 'gpt-3.5-turbo',
                    messages: [
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.3,
                    max_tokens: 2000
                });
                
                return response.choices[0].message.content;
            }
            
            displayUpdatedDocuments() {
                const section = document.getElementById('updated-documents-section');
                const preview = document.getElementById('updated-documents-preview');
                
                section.style.display = 'block';
                preview.innerHTML = '';
                
                this.updatedDocuments.forEach((doc, index) => {
                    const docElement = document.createElement('div');
                    docElement.className = 'mb-6 p-4 border border-gray-200 rounded-lg';
                    docElement.innerHTML = `
                        <h4 class="font-semibold text-gray-800 mb-2 flex items-center gap-2">
                            <i class="fas fa-file-text"></i>
                            ${doc.originalName}
                        </h4>
                        <div class="bg-white p-3 rounded border max-h-48 overflow-y-auto">
                            <pre class="whitespace-pre-wrap text-sm">${doc.updatedContent}</pre>
                        </div>
                    `;
                    preview.appendChild(docElement);
                });
                
                // Show download button
                document.getElementById('download-updated-btn').style.display = 'inline-flex';
            }
            
            downloadUpdatedDocuments() {
                if (this.updatedDocuments.length === 0) {
                    this.workspace.showNotification('No updated documents to download', 'error');
                    return;
                }
                
                if (this.updatedDocuments.length === 1) {
                    // Single file download
                    const doc = this.updatedDocuments[0];
                    this.downloadSingleFile(doc.updatedContent, doc.originalName);
                } else {
                    // Multiple files - create a zip or download individually
                    this.downloadMultipleFiles();
                }
            }
            
            downloadSingleFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            downloadMultipleFiles() {
                // Download each file individually
                this.updatedDocuments.forEach(doc => {
                    setTimeout(() => {
                        this.downloadSingleFile(doc.updatedContent, doc.originalName);
                    }, 100); // Small delay between downloads
                });
                
                this.workspace.showNotification(`Downloading ${this.updatedDocuments.length} files...`, 'success');
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }
        
        // Initialize the application
        let workspace;
        
        document.addEventListener('DOMContentLoaded', () => {
            workspace = new SmartDocumentWorkspace();
            window.workspace = workspace; // Make it globally accessible
        });
    </script>
</body>
</html>

